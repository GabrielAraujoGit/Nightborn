<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Clone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: #87CEEB;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
            text-shadow: 1px 1px 2px black;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 99;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }

        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }

        #crosshair::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
        }

        #inventory {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            z-index: 100;
        }

        .block-selector {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            text-shadow: 1px 1px 2px black;
            font-weight: bold;
        }

        .block-selector:hover {
            border-color: white;
            transform: scale(1.1);
        }

        .block-selector.active {
            border-color: yellow;
            box-shadow: 0 0 10px yellow;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px black;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div id="loading">Carregando...</div>
    
    <div id="info">
        <strong>üéÆ Minecraft Clone</strong><br>
        WASD - Mover | Espa√ßo - Pular<br>
        Mouse - Olhar | ESC - Liberar mouse<br>
        Click Esq - Remover | Click Dir - Adicionar<br>
        1-7 - Selecionar bloco<br>
        <span id="time-display">‚òÄÔ∏è Dia</span> | <span id="dimension-display">üåç Overworld</span><br>
        <span id="health-display">‚ù§Ô∏è Vida: 100</span>
    </div>

    <div id="crosshair"></div>

    <div id="inventory">
        <div class="block-selector active" data-type="grass" style="background: linear-gradient(to bottom, #7CFC00 0%, #228B22 100%);">Grama</div>
        <div class="block-selector" data-type="dirt" style="background: #8B4513;">Terra</div>
        <div class="block-selector" data-type="stone" style="background: #808080;">Pedra</div>
        <div class="block-selector" data-type="wood" style="background: #8B4513; background-image: repeating-linear-gradient(90deg, transparent, transparent 5px, rgba(0,0,0,0.1) 5px, rgba(0,0,0,0.1) 10px);">Madeira</div>
        <div class="block-selector" data-type="sand" style="background: #F4A460;">Areia</div>
        <div class="block-selector" data-type="water" style="background: #1E90FF;">√Ågua</div>
        <div class="block-selector" data-type="portal" style="background: linear-gradient(45deg, #8B00FF 0%, #4B0082 50%, #8B00FF 100%);">Portal</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Configura√ß√£o b√°sica
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Sistema de tempo (dia/noite)
        let timeOfDay = 0; // 0-1 (0=amanhecer, 0.25=dia, 0.5=entardecer, 0.75=noite)
        let currentDimension = 'overworld'; // 'overworld' ou 'nether'

        // Ilumina√ß√£o
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);

        // Materiais dos blocos
        const materials = {
            grass: new THREE.MeshLambertMaterial({ color: 0x7CFC00 }),
            dirt: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
            stone: new THREE.MeshLambertMaterial({ color: 0x808080 }),
            wood: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
            sand: new THREE.MeshLambertMaterial({ color: 0xF4A460 }),
            water: new THREE.MeshLambertMaterial({ 
                color: 0x1E90FF, 
                transparent: true, 
                opacity: 0.7 
            }),
            portal: new THREE.MeshLambertMaterial({ 
                color: 0x8B00FF,
                emissive: 0x8B00FF,
                emissiveIntensity: 0.5
            }),
            netherrack: new THREE.MeshLambertMaterial({ color: 0x8B0000 }),
            glowstone: new THREE.MeshLambertMaterial({ 
                color: 0xFFD700,
                emissive: 0xFFD700,
                emissiveIntensity: 1
            })
        };

        // Geometrias
        const blockSize = 10;
        const blockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
        const mobGeometry = new THREE.BoxGeometry(8, 15, 8);

        // Armazenamento
        const blocks = new Map();
        const mobs = [];
        let selectedBlockType = 'grass';
        let playerHealth = 100;

        // Fun√ß√£o para criar chave √∫nica para posi√ß√£o
        function positionKey(x, y, z) {
            return `${Math.round(x)},${Math.round(y)},${Math.round(z)}`;
        }

        // Adicionar bloco
        function addBlock(x, y, z, type = selectedBlockType) {
            const key = positionKey(x, y, z);
            if (blocks.has(key)) return;

            const block = new THREE.Mesh(blockGeometry, materials[type] || materials.stone);
            block.position.set(x, y, z);
            block.castShadow = true;
            block.receiveShadow = true;
            scene.add(block);
            blocks.set(key, { mesh: block, type: type });

            // Se for um portal, verificar se deve teleportar
            if (type === 'portal') {
                checkPortalStructure(x, y, z);
            }
        }

        // Remover bloco
        function removeBlock(x, y, z) {
            const key = positionKey(x, y, z);
            const block = blocks.get(key);
            if (block) {
                scene.remove(block.mesh);
                blocks.delete(key);
            }
        }

        // Verificar estrutura do portal (simples)
        function checkPortalStructure(x, y, z) {
            // Portal ativa se tiver 4 blocos em formato de quadrado
            const portalBlocks = [
                positionKey(x, y, z),
                positionKey(x + blockSize, y, z),
                positionKey(x, y + blockSize, z),
                positionKey(x + blockSize, y + blockSize, z)
            ];

            const allPortal = portalBlocks.every(key => {
                const block = blocks.get(key);
                return block && block.type === 'portal';
            });

            if (allPortal) {
                console.log('Portal ativado!');
            }
        }

        // Gerar terreno Overworld
        function generateOverworld() {
            clearWorld();
            const size = 20;
            for (let x = -size; x <= size; x += blockSize) {
                for (let z = -size; z <= size; z += blockSize) {
                    const noise = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 10;
                    const height = Math.floor(noise);
                    
                    addBlock(x, height, z, 'grass');
                    
                    for (let y = height - blockSize; y >= height - blockSize * 2; y -= blockSize) {
                        addBlock(x, y, z, 'dirt');
                    }
                    
                    for (let y = height - blockSize * 3; y >= height - blockSize * 4; y -= blockSize) {
                        addBlock(x, y, z, 'stone');
                    }
                }
            }

            // √Årvores
            for (let i = 0; i < 5; i++) {
                const treeX = (Math.random() - 0.5) * 200;
                const treeZ = (Math.random() - 0.5) * 200;
                const treeHeight = 30;
                
                for (let y = 0; y < treeHeight; y += blockSize) {
                    addBlock(treeX, y, treeZ, 'wood');
                }
                
                for (let dx = -blockSize; dx <= blockSize; dx += blockSize) {
                    for (let dz = -blockSize; dz <= blockSize; dz += blockSize) {
                        for (let dy = 0; dy < blockSize * 2; dy += blockSize) {
                            if (Math.random() > 0.3) {
                                addBlock(treeX + dx, treeHeight + dy, treeZ + dz, 'grass');
                            }
                        }
                    }
                }
            }

            // Spawnar mobs passivos no dia
            spawnMobs(3, 'pig');
        }

        // Gerar terreno Nether
        function generateNether() {
            clearWorld();
            const size = 20;
            for (let x = -size; x <= size; x += blockSize) {
                for (let z = -size; z <= size; z += blockSize) {
                    const noise = Math.sin(x * 0.15) * Math.cos(z * 0.15) * 5;
                    const height = Math.floor(noise);
                    
                    // Ch√£o de netherrack
                    for (let y = height - blockSize * 3; y >= height - blockSize * 6; y -= blockSize) {
                        addBlock(x, y, z, 'netherrack');
                    }
                    
                    // Glowstone aleat√≥rio no teto
                    if (Math.random() > 0.7) {
                        addBlock(x, height + blockSize * 5, z, 'glowstone');
                    }
                }
            }

            // Pilares de netherrack
            for (let i = 0; i < 8; i++) {
                const pillarX = (Math.random() - 0.5) * 200;
                const pillarZ = (Math.random() - 0.5) * 200;
                for (let y = -30; y < 50; y += blockSize) {
                    addBlock(pillarX, y, pillarZ, 'netherrack');
                }
            }

            // Spawnar mobs hostis no Nether
            spawnMobs(5, 'zombie_pigman');
        }

        // Limpar mundo
        function clearWorld() {
            blocks.forEach(block => scene.remove(block.mesh));
            blocks.clear();
            mobs.forEach(mob => scene.remove(mob.mesh));
            mobs.length = 0;
        }

        // Trocar dimens√£o
        function switchDimension() {
            if (currentDimension === 'overworld') {
                currentDimension = 'nether';
                generateNether();
                scene.background = new THREE.Color(0x330000);
                scene.fog = new THREE.Fog(0x330000, 0, 200);
                document.getElementById('dimension-display').textContent = 'üî• Nether';
            } else {
                currentDimension = 'overworld';
                generateOverworld();
                updateSkyColor();
                document.getElementById('dimension-display').textContent = 'üåç Overworld';
            }
            player.position.set(0, 50, 50);
        }

        // Classe Mob
        class Mob {
            constructor(type, position) {
                this.type = type;
                this.position = position.clone();
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.health = 20;
                this.hostile = type === 'zombie' || type === 'zombie_pigman';
                
                // Criar mesh
                const color = this.hostile ? 0x00FF00 : 0xFFC0CB;
                const material = new THREE.MeshLambertMaterial({ color: color });
                this.mesh = new THREE.Mesh(mobGeometry, material);
                this.mesh.position.copy(this.position);
                this.mesh.castShadow = true;
                scene.add(this.mesh);

                // IA
                this.targetPlayer = false;
                this.moveTimer = 0;
                this.moveDirection = new THREE.Vector3();
            }

            update(playerPos) {
                // Gravidade
                this.velocity.y -= 0.04;
                
                // IA de movimento
                this.moveTimer--;
                if (this.moveTimer <= 0) {
                    this.moveTimer = Math.random() * 100 + 50;
                    
                    if (this.hostile) {
                        // Mobs hostis perseguem o jogador √† noite ou no Nether
                        const distance = this.position.distanceTo(playerPos);
                        if (distance < 100 && (timeOfDay > 0.6 || currentDimension === 'nether')) {
                            this.moveDirection.subVectors(playerPos, this.position).normalize();
                            this.targetPlayer = true;
                        } else {
                            this.moveDirection.set(
                                (Math.random() - 0.5) * 2,
                                0,
                                (Math.random() - 0.5) * 2
                            ).normalize();
                            this.targetPlayer = false;
                        }
                    } else {
                        // Mobs passivos andam aleatoriamente
                        this.moveDirection.set(
                            (Math.random() - 0.5) * 2,
                            0,
                            (Math.random() - 0.5) * 2
                        ).normalize();
                    }
                }

                // Aplicar movimento
                const speed = this.targetPlayer ? 0.3 : 0.1;
                this.velocity.x = this.moveDirection.x * speed;
                this.velocity.z = this.moveDirection.z * speed;

                this.position.add(this.velocity);

                // Colis√£o com ch√£o
                if (this.position.y < 10) {
                    this.position.y = 10;
                    this.velocity.y = 0;
                }

                this.mesh.position.copy(this.position);

                // Atacar jogador se pr√≥ximo e hostil
                if (this.hostile && this.targetPlayer) {
                    const distance = this.position.distanceTo(playerPos);
                    if (distance < 15 && Math.random() > 0.98) {
                        damagePlayer(5);
                    }
                }
            }

            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    this.die();
                }
            }

            die() {
                scene.remove(this.mesh);
                const index = mobs.indexOf(this);
                if (index > -1) {
                    mobs.splice(index, 1);
                }
            }
        }

        // Spawnar mobs
        function spawnMobs(count, type) {
            for (let i = 0; i < count; i++) {
                const x = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                const y = 50;
                const mob = new Mob(type, new THREE.Vector3(x, y, z));
                mobs.push(mob);
            }
        }

        // Dano ao jogador
        function damagePlayer(amount) {
            playerHealth = Math.max(0, playerHealth - amount);
            document.getElementById('health-display').textContent = `‚ù§Ô∏è Vida: ${playerHealth}`;
            
            if (playerHealth <= 0) {
                alert('Voc√™ morreu! Reiniciando...');
                playerHealth = 100;
                player.position.set(0, 50, 50);
                document.getElementById('health-display').textContent = `‚ù§Ô∏è Vida: ${playerHealth}`;
            }
        }

        // Atualizar ciclo dia/noite
        function updateDayNightCycle() {
            if (currentDimension !== 'overworld') return;
            
            timeOfDay += 0.0002;
            if (timeOfDay > 1) timeOfDay = 0;

            updateSkyColor();
            updateLighting();

            // Spawnar zombies √† noite
            if (timeOfDay > 0.6 && timeOfDay < 0.61 && Math.random() > 0.5) {
                spawnMobs(2, 'zombie');
            }

            // Despawnar zombies de dia
            if (timeOfDay > 0.1 && timeOfDay < 0.11) {
                mobs.forEach(mob => {
                    if (mob.type === 'zombie') {
                        mob.die();
                    }
                });
            }
        }

        // Atualizar cor do c√©u
        function updateSkyColor() {
            if (currentDimension !== 'overworld') return;
            
            let color, fogColor;
            
            if (timeOfDay < 0.25) {
                // Amanhecer
                color = new THREE.Color().lerpColors(
                    new THREE.Color(0x001a33),
                    new THREE.Color(0x87CEEB),
                    timeOfDay * 4
                );
            } else if (timeOfDay < 0.5) {
                // Dia
                color = new THREE.Color(0x87CEEB);
            } else if (timeOfDay < 0.75) {
                // Entardecer
                color = new THREE.Color().lerpColors(
                    new THREE.Color(0x87CEEB),
                    new THREE.Color(0xFF6347),
                    (timeOfDay - 0.5) * 4
                );
            } else {
                // Noite
                color = new THREE.Color().lerpColors(
                    new THREE.Color(0xFF6347),
                    new THREE.Color(0x001a33),
                    (timeOfDay - 0.75) * 4
                );
            }

            scene.background = color;
            scene.fog = new THREE.Fog(color, 0, 400);
        }

        // Atualizar ilumina√ß√£o
        function updateLighting() {
            if (currentDimension !== 'overworld') return;
            
            let intensity;
            
            if (timeOfDay < 0.25 || timeOfDay > 0.75) {
                intensity = 0.3;
                document.getElementById('time-display').textContent = 'üåô Noite';
            } else if (timeOfDay < 0.5) {
                intensity = 0.8;
                document.getElementById('time-display').textContent = '‚òÄÔ∏è Dia';
            } else {
                intensity = 0.5;
                document.getElementById('time-display').textContent = 'üåÖ Entardecer';
            }

            directionalLight.intensity = intensity;
            ambientLight.intensity = intensity * 0.75;
        }

        // Controles do jogador
        const player = {
            position: new THREE.Vector3(0, 50, 50),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: new THREE.Euler(0, 0, 0, 'YXZ'),
            speed: 0.5,
            jumpPower: 1.5,
            onGround: false
        };

        camera.position.copy(player.position);

        // Controles de teclado
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            // Sele√ß√£o de blocos com n√∫meros
            if (e.key >= '1' && e.key <= '7') {
                const types = ['grass', 'dirt', 'stone', 'wood', 'sand', 'water', 'portal'];
                selectedBlockType = types[parseInt(e.key) - 1];
                updateInventoryUI();
            }

            // Tecla N para trocar dimens√£o
            if (e.key.toLowerCase() === 'n') {
                switchDimension();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Controles do mouse
        let mouseX = 0, mouseY = 0;
        let isPointerLocked = false;

        renderer.domElement.addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isPointerLocked) return;
            
            mouseX += e.movementX * 0.002;
            mouseY += e.movementY * 0.002;
            mouseY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouseY));
            
            player.rotation.set(mouseY, mouseX, 0);
        });

        // Raycaster
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(0, 0);

        // Click do mouse
        renderer.domElement.addEventListener('mousedown', (e) => {
            if (!isPointerLocked) return;

            raycaster.setFromCamera(mouse, camera);
            
            // Verificar blocos
            const blockIntersects = [];
            blocks.forEach((block) => {
                const intersect = raycaster.intersectObject(block.mesh);
                if (intersect.length > 0) {
                    blockIntersects.push({ ...intersect[0], block: block });
                }
            });

            // Verificar mobs
            const mobIntersects = [];
            mobs.forEach((mob) => {
                const intersect = raycaster.intersectObject(mob.mesh);
                if (intersect.length > 0) {
                    mobIntersects.push({ ...intersect[0], mob: mob });
                }
            });

            if (e.button === 0) {
                // Atacar mobs primeiro
                if (mobIntersects.length > 0) {
                    mobIntersects.sort((a, b) => a.distance - b.distance);
                    mobIntersects[0].mob.takeDamage(10);
                } else if (blockIntersects.length > 0) {
                    blockIntersects.sort((a, b) => a.distance - b.distance);
                    const hit = blockIntersects[0];
                    const pos = hit.block.mesh.position;
                    removeBlock(pos.x, pos.y, pos.z);
                }
            } else if (e.button === 2) {
                if (blockIntersects.length > 0) {
                    blockIntersects.sort((a, b) => a.distance - b.distance);
                    const hit = blockIntersects[0];
                    const normal = hit.face.normal;
                    const pos = hit.block.mesh.position;
                    const newPos = new THREE.Vector3(
                        pos.x + normal.x * blockSize,
                        pos.y + normal.y * blockSize,
                        pos.z + normal.z * blockSize
                    );
                    addBlock(newPos.x, newPos.y, newPos.z);
                }
            }
        });

        renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

        // Atualizar UI do invent√°rio
        function updateInventoryUI() {
            document.querySelectorAll('.block-selector').forEach(el => {
                el.classList.remove('active');
                if (el.dataset.type === selectedBlockType) {
                    el.classList.add('active');
                }
            });
        }

        // Click nos seletores de bloco
        document.querySelectorAll('.block-selector').forEach(el => {
            el.addEventListener('click', () => {
                selectedBlockType = el.dataset.type;
                updateInventoryUI();
            });
        });

        // F√≠sica e movimento
        function updatePlayer() {
            player.velocity.y -= 0.04;

            const direction = new THREE.Vector3();
            const forward = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(0, player.rotation.y, 0));
            const right = new THREE.Vector3(1, 0, 0).applyEuler(new THREE.Euler(0, player.rotation.y, 0));

            if (keys['w']) direction.add(forward);
            if (keys['s']) direction.sub(forward);
            if (keys['d']) direction.add(right);
            if (keys['a']) direction.sub(right);

            if (direction.length() > 0) {
                direction.normalize();
                player.velocity.x = direction.x * player.speed;
                player.velocity.z = direction.z * player.speed;
            } else {
                player.velocity.x *= 0.8;
                player.velocity.z *= 0.8;
            }

            if (keys[' '] && player.onGround) {
                player.velocity.y = player.jumpPower;
            }

            player.position.add(player.velocity);

            if (player.position.y < 20) {
                player.position.y = 20;
                player.velocity.y = 0;
                player.onGround = true;
            } else {
                player.onGround = false;
            }

            camera.position.copy(player.position);
            camera.rotation.copy(player.rotation);
        }

        // Loop de anima√ß√£o
        function animate() {
            requestAnimationFrame(animate);
            updatePlayer();
            updateDayNightCycle();
            
            // Atualizar mobs
            mobs.forEach(mob => mob.update(player.position));
            
            renderer.render(scene, camera);
        }

        // Redimensionar janela
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Inicializar
        generateOverworld();
        updateSkyColor();
        document.getElementById('loading').style.display = 'none';
        animate();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft - Java Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        body {
            overflow: hidden;
            font-family: 'VT323', monospace;
            background: #000;
            cursor: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAPCAYAAAA71pVKAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAdgAAAHYBTnsmCAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAABNSURBVCiR7dMxDQAwDATB+zfNC6ioRQqk6FPlBKI2SjaeVn3JK6rqiPNpZl0TQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQ/u4BUEwEiP0H/OQAAAAASUVORK5CYII='), auto;
        }

        /* ==================== MENU PRINCIPAL ==================== */
        #mainMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="400" height="400"><defs><pattern id="dirt" width="16" height="16" patternUnits="userSpaceOnUse"><rect fill="%23654321" width="16" height="16"/><rect fill="%234a3319" x="0" y="0" width="4" height="4"/><rect fill="%234a3319" x="8" y="4" width="4" height="4"/><rect fill="%234a3319" x="4" y="8" width="4" height="4"/><rect fill="%234a3319" x="12" y="12" width="4" height="4"/></pattern></defs><rect fill="url(%23dirt)" width="400" height="400"/></svg>');
            background-size: 64px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: panorama 120s linear infinite;
        }

        @keyframes panorama {
            0% { background-position: 0 0; }
            100% { background-position: -1920px -1080px; }
        }

        #mainMenu::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.5) 100%);
        }

        .minecraft-logo {
            position: relative;
            font-size: 120px;
            color: #fff;
            text-shadow: 
                6px 6px 0 #3f3f3f,
                6px 0 0 #3f3f3f,
                0 6px 0 #3f3f3f,
                -2px -2px 0 #ffff00;
            margin-bottom: 60px;
            letter-spacing: 8px;
            animation: logoFloat 3s ease-in-out infinite, logoGlow 2s ease-in-out infinite;
            z-index: 2;
        }

        @keyframes logoFloat {
            0%, 100% { transform: translateY(0px) rotate(-1deg); }
            50% { transform: translateY(-15px) rotate(1deg); }
        }

        @keyframes logoGlow {
            0%, 100% { filter: drop-shadow(0 0 20px rgba(255,255,0,0.3)); }
            50% { filter: drop-shadow(0 0 40px rgba(255,255,0,0.6)); }
        }

        .menu-container {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .menu-button {
            min-width: 400px;
            padding: 12px 24px;
            font-size: 24px;
            font-family: 'VT323', monospace;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            border-top: 3px solid rgba(255,255,255,0.3);
            border-left: 3px solid rgba(255,255,255,0.3);
            border-right: 3px solid rgba(0,0,0,0.5);
            border-bottom: 3px solid rgba(0,0,0,0.5);
            cursor: pointer;
            text-align: center;
            transition: all 0.1s;
            text-shadow: 2px 2px 0 #000;
            position: relative;
        }

        .menu-button:hover {
            background: rgba(100, 100, 255, 0.6);
            border-top: 3px solid rgba(150,150,255,0.8);
            border-left: 3px solid rgba(150,150,255,0.8);
            transform: scale(1.02);
        }

        .menu-button:active {
            background: rgba(50, 50, 200, 0.8);
            border-top: 3px solid rgba(0,0,0,0.5);
            border-left: 3px solid rgba(0,0,0,0.5);
            border-right: 3px solid rgba(255,255,255,0.3);
            border-bottom: 3px solid rgba(255,255,255,0.3);
            transform: scale(0.98);
        }

        /* ==================== CANVAS DO JOGO ==================== */
        #gameCanvas {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* ==================== HUD ==================== */
        #gameHUD {
            display: none;
            pointer-events: none;
        }

        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 32px;
            height: 32px;
            z-index: 100;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 2px rgba(0,0,0,0.8), inset 0 0 2px rgba(0,0,0,0.5);
        }

        #crosshair::before {
            width: 4px;
            height: 32px;
            left: 14px;
            top: 0;
        }

        #crosshair::after {
            width: 32px;
            height: 4px;
            left: 0;
            top: 14px;
        }

        /* ==================== HOTBAR ==================== */
        #hotbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0;
            z-index: 101;
            pointer-events: all;
            filter: drop-shadow(4px 4px 0 rgba(0,0,0,0.4));
        }

        .hotbar-slot {
            width: 64px;
            height: 64px;
            background: rgba(139, 139, 139, 0.85);
            border: 3px solid;
            border-color: rgba(55, 55, 55, 0.9) rgba(255, 255, 255, 0.9) rgba(255, 255, 255, 0.9) rgba(55, 55, 55, 0.9);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.1s;
        }

        .hotbar-slot:hover {
            background: rgba(169, 169, 169, 0.85);
        }

        .hotbar-slot.selected {
            border: 4px solid;
            border-color: rgba(255, 255, 255, 1) rgba(55, 55, 55, 1) rgba(55, 55, 55, 1) rgba(255, 255, 255, 1);
            background: rgba(169, 169, 169, 0.95);
        }

        .slot-item {
            width: 48px;
            height: 48px;
            image-rendering: pixelated;
        }

        .slot-count {
            position: absolute;
            bottom: 4px;
            right: 4px;
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.8);
            font-family: 'VT323', monospace;
            pointer-events: none;
        }

        /* ==================== BARRA DE VIDA E FOME ==================== */
        #statusBars {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 101;
            pointer-events: none;
        }

        .status-bar {
            display: flex;
            gap: 2px;
        }

        .heart, .hunger {
            width: 24px;
            height: 24px;
            background-size: contain;
            filter: drop-shadow(1px 1px 0 rgba(0,0,0,0.5));
        }

        .heart {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23ff0000" d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z"/></svg>');
        }

        .heart.half {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23ff0000" d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08V21.35Z"/><path fill="%23550000" d="M12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35V5.08Z"/></svg>');
        }

        .heart.empty {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23550000" d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z"/></svg>');
        }

        .hunger {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23cd853f" d="M18.06,23H5.94C5.42,23 5,22.58 5,22.06V12C5,10.34 6.34,9 8,9H16C17.66,9 19,10.34 19,12V22.06C19,22.58 18.58,23 18.06,23M12,1L8,5V8H16V5L12,1Z"/></svg>');
        }

        .hunger.empty {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23553311" d="M18.06,23H5.94C5.42,23 5,22.58 5,22.06V12C5,10.34 6.34,9 8,9H16C17.66,9 19,10.34 19,12V22.06C19,22.58 18.58,23 18.06,23M12,1L8,5V8H16V5L12,1Z"/></svg>');
        }

        /* ==================== DEBUG INFO ==================== */
        #debugInfo {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 12px;
            font-size: 18px;
            font-family: 'VT323', monospace;
            z-index: 102;
            border: 2px solid rgba(255,255,255,0.3);
            pointer-events: none;
            line-height: 1.4;
        }

        /* ==================== INVENTORY ==================== */
        #inventory {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(198, 198, 198, 0.98);
            border: 4px solid;
            border-color: rgba(255,255,255,0.9) rgba(55,55,55,0.9) rgba(55,55,55,0.9) rgba(255,255,255,0.9);
            padding: 20px;
            display: none;
            z-index: 500;
            pointer-events: all;
        }

        #inventory h2 {
            font-size: 32px;
            color: #3f3f3f;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0 rgba(255,255,255,0.5);
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(9, 64px);
            gap: 4px;
            margin: 20px 0;
        }

        .inventory-slot {
            width: 64px;
            height: 64px;
            background: rgba(139, 139, 139, 0.85);
            border: 2px solid;
            border-color: rgba(55, 55, 55, 0.9) rgba(255, 255, 255, 0.9) rgba(255, 255, 255, 0.9) rgba(55, 55, 55, 0.9);
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .inventory-slot:hover {
            background: rgba(169, 169, 169, 0.95);
        }

        .crafting-grid {
            display: grid;
            grid-template-columns: repeat(3, 64px);
            gap: 4px;
        }

        /* ==================== PAUSE MENU ==================== */
        #pauseMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 600;
            pointer-events: all;
        }

        .pause-container {
            background: rgba(100, 100, 100, 0.95);
            padding: 40px;
            border: 4px solid;
            border-color: rgba(255,255,255,0.9) rgba(55,55,55,0.9) rgba(55,55,55,0.9) rgba(255,255,255,0.9);
        }

        .pause-container h2 {
            font-size: 48px;
            color: white;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 3px 3px 0 rgba(0,0,0,0.5);
        }

        /* ==================== LOADING ==================== */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 999;
        }

        .loading-text {
            color: white;
            font-size: 32px;
            margin-bottom: 20px;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .loading-bar {
            width: 400px;
            height: 40px;
            background: rgba(100, 100, 100, 0.8);
            border: 3px solid rgba(255,255,255,0.5);
            position: relative;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00aa00);
            width: 0%;
            transition: width 0.3s;
        }

        /* ==================== MESSAGES ==================== */
        #messages {
            position: fixed;
            top: 100px;
            left: 10px;
            z-index: 150;
            pointer-events: none;
        }

        .message {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            margin: 4px 0;
            font-size: 20px;
            font-family: 'VT323', monospace;
            border-left: 3px solid #ffff00;
            animation: slideIn 0.3s, fadeOut 0.5s 4.5s;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes fadeOut {
            to { opacity: 0; }
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- MENU PRINCIPAL -->
    <div id="mainMenu">
        <div class="minecraft-logo">MINECRAFT</div>
        <div class="menu-container">
            <button class="menu-button" onclick="startGame('survival')">üéÆ Singleplayer</button>
            <button class="menu-button" onclick="startGame('creative')">‚ú® Modo Criativo</button>
            <button class="menu-button" onclick="loadGame()">üìÇ Carregar Mundo</button>
            <button class="menu-button" onclick="showOptions()">‚öôÔ∏è Op√ß√µes</button>
            <button class="menu-button" onclick="quitGame()">üö™ Sair do Jogo</button>
        </div>
    </div>

    <!-- LOADING -->
    <div id="loading">
        <div class="loading-text">Gerando mundo...</div>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
    </div>

    <!-- CANVAS DO JOGO -->
    <canvas id="gameCanvas"></canvas>

    <!-- HUD DO JOGO -->
    <div id="gameHUD">
        <div id="crosshair"></div>
        
        <div id="debugInfo">
            <div>Minecraft 1.20.1</div>
            <div id="fpsCounter">FPS: 60</div>
            <div id="posInfo">X: 0 Y: 64 Z: 0</div>
            <div id="biomeInfo">Bioma: Plan√≠cie</div>
            <div id="timeInfo">Dia 1, 08:00</div>
        </div>

        <div id="statusBars">
            <div class="status-bar" id="healthBar"></div>
            <div class="status-bar" id="hungerBar"></div>
        </div>

        <div id="hotbar"></div>

        <div id="messages"></div>
    </div>

    <!-- INVENT√ÅRIO -->
    <div id="inventory">
        <h2>Invent√°rio</h2>
        
        <div style="margin-bottom: 20px;">
            <h3 style="color: #3f3f3f; margin-bottom: 10px;">Crafting</h3>
            <div style="display: flex; gap: 20px; align-items: center;">
                <div class="crafting-grid" id="craftingGrid"></div>
                <div style="font-size: 48px; color: #3f3f3f;">‚Üí</div>
                <div class="inventory-slot" id="craftingResult"></div>
            </div>
        </div>
        
        <div>
            <h3 style="color: #3f3f3f; margin-bottom: 10px;">Invent√°rio</h3>
            <div class="inventory-grid" id="inventoryGrid"></div>
        </div>
        
        <div style="margin-top: 20px;">
            <h3 style="color: #3f3f3f; margin-bottom: 10px;">Hotbar</h3>
            <div class="inventory-grid" id="inventoryHotbar" style="grid-template-columns: repeat(9, 64px);"></div>
        </div>
        
        <button class="menu-button" style="margin-top: 20px; width: 100%;" onclick="closeInventory()">Fechar (E)</button>
    </div>

    <!-- PAUSE MENU -->
    <div id="pauseMenu">
        <div class="pause-container">
            <h2>Menu do Jogo</h2>
            <button class="menu-button" style="width: 100%; margin: 8px 0;" onclick="resumeGame()">Voltar ao Jogo</button>
            <button class="menu-button" style="width: 100%; margin: 8px 0;" onclick="saveGame()">üíæ Salvar Jogo</button>
            <button class="menu-button" style="width: 100%; margin: 8px 0;" onclick="showOptions()">‚öôÔ∏è Op√ß√µes</button>
            <button class="menu-button" style="width: 100%; margin: 8px 0;" onclick="quitToMenu()">üö™ Sair</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==================== SISTEMA DE √ÅUDIO ====================
        class AudioSystem {
            constructor() {
                this.context = null;
                this.sounds = {};
                this.music = null;
                this.musicVolume = 0.3;
                this.sfxVolume = 0.5;
            }

            init() {
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                    this.createSounds();
                } catch(e) {
                    console.log('Audio n√£o dispon√≠vel');
                }
            }

            createSounds() {
                // Sons b√°sicos do Minecraft
                this.sounds = {
                    step_grass: { freq: 220, duration: 0.05, type: 'sine' },
                    step_stone: { freq: 180, duration: 0.06, type: 'triangle' },
                    step_wood: { freq: 200, duration: 0.05, type: 'square' },
                    dig_grass: { freq: 300, duration: 0.15, type: 'sawtooth' },
                    dig_stone: { freq: 150, duration: 0.2, type: 'square' },
                    dig_wood: { freq: 250, duration: 0.15, type: 'triangle' },
                    place: { freq: 400, duration: 0.1, type: 'sine' },
                    hurt: { freq: 100, duration: 0.3, type: 'sawtooth' },
                    eat: { freq: 350, duration: 0.08, type: 'sine' },
                    jump: { freq: 300, duration: 0.1, type: 'triangle' },
                    splash: { freq: 200, duration: 0.2, type: 'sine' },
                    click: { freq: 600, duration: 0.05, type: 'square' }
                };
            }

            playSound(soundName, volume = 1) {
                if (!this.context || !this.sounds[soundName]) return;

                const sound = this.sounds[soundName];
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();

                osc.connect(gain);
                gain.connect(this.context.destination);

                osc.type = sound.type;
                osc.frequency.value = sound.freq;

                gain.gain.setValueAtTime(this.sfxVolume * volume, this.context.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + sound.duration);

                osc.start(this.context.currentTime);
                osc.stop(this.context.currentTime + sound.duration);
            }

            playMusic() {
                if (!this.context) return;
                
                // M√∫sica ambiente simples (C418 inspired)
                const playNote = (freq, duration, delay) => {
                    setTimeout(() => {
                        const osc = this.context.createOscillator();
                        const gain = this.context.createGain();
                        
                        osc.connect(gain);
                        gain.connect(this.context.destination);
                        
                        osc.type = 'sine';
                        osc.frequency.value = freq;
                        
                        gain.gain.setValueAtTime(this.musicVolume, this.context.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);
                        
                        osc.start(this.context.currentTime);
                        osc.stop(this.context.currentTime + duration);
                    }, delay);
                };

                // Loop musical simples
                const melody = [
                    [523.25, 1, 0],    // C5
                    [587.33, 1, 1000], // D5
                    [659.25, 1, 2000], // E5
                    [523.25, 2, 3000], // C5
                    [440.00, 2, 5000], // A4
                    [392.00, 2, 7000], // G4
                ];

                melody.forEach(([freq, dur, delay]) => {
                    playNote(freq, dur, delay);
                });

                setTimeout(() => this.playMusic(), 9000);
            }
        }

        const audio = new AudioSystem();

        // ==================== CONFIGURA√á√ÉO DO JOGO ====================
        const config = {
            renderDistance: 8,
            chunkSize: 16,
            blockSize: 1,
            gravity: 0.032,
            jumpForce: 0.42,
            walkSpeed: 0.15,
            sprintSpeed: 0.24,
            flySpeed: 0.3,
            mouseSensitivity: 0.002
        };

        const gameState = {
            mode: 'survival',
            paused: false,
            inventoryOpen: false,
            day: 1,
            time: 0,
            health: 20,
            hunger: 20,
            selectedSlot: 0,
            isFlying: false,
            isSprinting: false
        };

        // ==================== TIPOS DE BLOCOS ====================
        const BlockType = {
            AIR: 0,
            GRASS: 1,
            DIRT: 2,
            STONE: 3,
            WOOD: 4,
            LEAVES: 5,
            SAND: 6,
            WATER: 7,
            COAL_ORE: 8,
            IRON_ORE: 9,
            DIAMOND_ORE: 10,
            BEDROCK: 11,
            PLANKS: 12,
            CRAFTING_TABLE: 13,
            FURNACE: 14,
            GLASS: 15
        };

        const blockData = {
            [BlockType.GRASS]: { name: 'Grama', color: 0x7CFC00, hardness: 0.6, tool: 'shovel', drops: BlockType.DIRT },
            [BlockType.DIRT]: { name: 'Terra', color: 0x8B4513, hardness: 0.5, tool: 'shovel', drops: BlockType.DIRT },
            [BlockType.STONE]: { name: 'Pedra', color: 0x808080, hardness: 1.5, tool: 'pickaxe', drops: BlockType.STONE },
            [BlockType.WOOD]: { name: 'Madeira', color: 0xA0522D, hardness: 2.0, tool: 'axe', drops: BlockType.WOOD },
            [BlockType.LEAVES]: { name: 'Folhas', color: 0x228B22, hardness: 0.2, tool: 'shears', transparent: true },
            [BlockType.SAND]: { name: 'Areia', color: 0xF4A460, hardness: 0.5, tool: 'shovel', drops: BlockType.SAND },
            [BlockType.WATER]: { name: '√Ågua', color: 0x1E90FF, hardness: -1, transparent: true },
            [BlockType.COAL_ORE]: { name: 'Carv√£o', color: 0x1a1a1a, hardness: 3.0, tool: 'pickaxe', drops: BlockType.COAL_ORE },
            [BlockType.IRON_ORE]: { name: 'Ferro', color: 0xd8d8d8, hardness: 3.0, tool: 'pickaxe', drops: BlockType.IRON_ORE },
            [BlockType.DIAMOND_ORE]: { name: 'Diamante', color: 0x00FFFF, hardness: 3.0, tool: 'pickaxe', drops: BlockType.DIAMOND_ORE },
            [BlockType.BEDROCK]: { name: 'Bedrock', color: 0x2a2a2a, hardness: -1 },
            [BlockType.PLANKS]: { name: 'T√°buas', color: 0xC19A6B, hardness: 2.0, tool: 'axe', drops: BlockType.PLANKS },
            [BlockType.CRAFTING_TABLE]: { name: 'Bancada', color: 0x8B4513, hardness: 2.5, tool: 'axe', drops: BlockType.CRAFTING_TABLE },
            [BlockType.GLASS]: { name: 'Vidro', color: 0xE0F7FA, hardness: 0.3, transparent: true }
        };

        // ==================== INVENT√ÅRIO E CRAFTING ====================
        class Inventory {
            constructor() {
                this.slots = new Array(36).fill(null).map(() => ({ type: null, count: 0 }));
                this.hotbar = new Array(9).fill(null).map(() => ({ type: null, count: 0 }));
                this.crafting = new Array(9).fill(null).map(() => ({ type: null, count: 0 }));
            }

            addItem(type, count = 1) {
                // Tenta adicionar aos slots existentes
                for (let slot of [...this.hotbar, ...this.slots]) {
                    if (slot.type === type && slot.count < 64) {
                        const canAdd = Math.min(count, 64 - slot.count);
                        slot.count += canAdd;
                        count -= canAdd;
                        if (count === 0) {
                            this.update();
                            return true;
                        }
                    }
                }

                // Tenta adicionar a slot vazio
                for (let slot of [...this.hotbar, ...this.slots]) {
                    if (slot.type === null) {
                        slot.type = type;
                        slot.count = count;
                        this.update();
                        return true;
                    }
                }

                showMessage('Invent√°rio cheio!');
                return false;
            }

            removeItem(type, count = 1) {
                for (let slot of [...this.hotbar, ...this.slots]) {
                    if (slot.type === type && slot.count >= count) {
                        slot.count -= count;
                        if (slot.count === 0) slot.type = null;
                        this.update();
                        return true;
                    }
                }
                return false;
            }

            hasItem(type, count = 1) {
                let total = 0;
                for (let slot of [...this.hotbar, ...this.slots]) {
                    if (slot.type === type) total += slot.count;
                }
                return total >= count;
            }

            update() {
                updateHotbarUI();
                updateInventoryUI();
            }
        }

        const inventory = new Inventory();

        // Receitas de crafting
        const recipes = [
            {
                pattern: [BlockType.WOOD, null, null, null, null, null, null, null, null],
                result: { type: BlockType.PLANKS, count: 4 }
            },
            {
                pattern: [BlockType.PLANKS, BlockType.PLANKS, null, BlockType.PLANKS, BlockType.PLANKS, null, null, null, null],
                result: { type: BlockType.CRAFTING_TABLE, count: 1 }
            },
            {
                pattern: [BlockType.STONE, BlockType.STONE, BlockType.STONE, BlockType.STONE, null, BlockType.STONE, BlockType.STONE, BlockType.STONE, BlockType.STONE],
                result: { type: BlockType.FURNACE, count: 1 }
            }
        ];

        function checkCrafting() {
            for (let recipe of recipes) {
                let matches = true;
                for (let i = 0; i < 9; i++) {
                    if (recipe.pattern[i] !== inventory.crafting[i].type) {
                        matches = false;
                        break;
                    }
                }
                if (matches) return recipe.result;
            }
            return null;
        }

        // ==================== THREE.JS SETUP ====================
        let scene, camera, renderer, controls;
        let chunks = new Map();
        let player = {
            position: new THREE.Vector3(0, 70, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: new THREE.Euler(0, 0, 0, 'YXZ'),
            onGround: false,
            inWater: false
        };

        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, config.renderDistance * config.chunkSize * 2);

            camera = new THREE.PerspectiveCamera(
                70,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.copy(player.position);

            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Ilumina√ß√£o
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            sun.shadow.camera.left = -100;
            sun.shadow.camera.right = 100;
            sun.shadow.camera.top = 100;
            sun.shadow.camera.bottom = -100;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            scene.add(sun);

            window.sun = sun;
            window.ambientLight = ambientLight;
        }

        // ==================== GERA√á√ÉO DE MUNDO ====================
        class Chunk {
            constructor(x, z) {
                this.x = x;
                this.z = z;
                this.blocks = new Uint8Array(config.chunkSize * 128 * config.chunkSize);
                this.mesh = null;
                this.generate();
            }

            generate() {
                for (let x = 0; x < config.chunkSize; x++) {
                    for (let z = 0; z < config.chunkSize; z++) {
                        const worldX = this.x * config.chunkSize + x;
                        const worldZ = this.z * config.chunkSize + z;

                        // Gera√ß√£o de terreno com Perlin noise simplificado
                        const height = Math.floor(
                            64 + 
                            Math.sin(worldX * 0.05) * 8 +
                            Math.cos(worldZ * 0.05) * 8 +
                            Math.sin(worldX * 0.02) * 4 +
                            Math.cos(worldZ * 0.02) * 4
                        );

                        // Bedrock
                        this.setBlock(x, 0, z, BlockType.BEDROCK);

                        // Pedra
                        for (let y = 1; y < height - 4; y++) {
                            this.setBlock(x, y, z, BlockType.STONE);
                            
                            // Min√©rios
                            if (Math.random() < 0.01 && y < 20) this.setBlock(x, y, z, BlockType.DIAMOND_ORE);
                            else if (Math.random() < 0.02 && y < 40) this.setBlock(x, y, z, BlockType.IRON_ORE);
                            else if (Math.random() < 0.03 && y < 60) this.setBlock(x, y, z, BlockType.COAL_ORE);
                        }

                        // Terra
                        for (let y = height - 4; y < height; y++) {
                            this.setBlock(x, y, z, BlockType.DIRT);
                        }

                        // Grama
                        this.setBlock(x, height, z, BlockType.GRASS);

                        // √Årvores
                        if (Math.random() < 0.02 && height > 62) {
                            for (let i = 0; i < 5; i++) {
                                this.setBlock(x, height + 1 + i, z, BlockType.WOOD);
                            }
                            // Folhas
                            for (let dx = -2; dx <= 2; dx++) {
                                for (let dz = -2; dz <= 2; dz++) {
                                    for (let dy = 0; dy < 3; dy++) {
                                        if (x + dx >= 0 && x + dx < config.chunkSize &&
                                            z + dz >= 0 && z + dz < config.chunkSize) {
                                            this.setBlock(x + dx, height + 5 + dy, z + dz, BlockType.LEAVES);
                                        }
                                    }
                                }
                            }
                        }

                        // √Ågua
                        if (height < 62) {
                            for (let y = height + 1; y <= 62; y++) {
                                this.setBlock(x, y, z, BlockType.WATER);
                            }
                        }
                    }
                }
            }

            setBlock(x, y, z, type) {
                if (x < 0 || x >= config.chunkSize || y < 0 || y >= 128 || z < 0 || z >= config.chunkSize) return;
                this.blocks[x + y * config.chunkSize + z * config.chunkSize * 128] = type;
            }

            getBlock(x, y, z) {
                if (x < 0 || x >= config.chunkSize || y < 0 || y >= 128 || z < 0 || z >= config.chunkSize) return BlockType.AIR;
                return this.blocks[x + y * config.chunkSize + z * config.chunkSize * 128];
            }

            buildMesh() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                }

                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const colors = [];
                const indices = [];
                let vertexCount = 0;

                for (let x = 0; x < config.chunkSize; x++) {
                    for (let y = 0; y < 128; y++) {
                        for (let z = 0; z < config.chunkSize; z++) {
                            const blockType = this.getBlock(x, y, z);
                            if (blockType === BlockType.AIR) continue;

                            const data = blockData[blockType];
                            if (!data) continue;

                            const worldX = this.x * config.chunkSize + x;
                            const worldZ = this.z * config.chunkSize + z;

                            // Verificar faces vis√≠veis
                            const faces = [
                                { dir: [0, 1, 0], corners: [[0,1,0],[1,1,0],[1,1,1],[0,1,1]] },  // Top
                                { dir: [0,-1, 0], corners: [[0,0,1],[1,0,1],[1,0,0],[0,0,0]] }, // Bottom
                                { dir: [0, 0, 1], corners: [[0,0,1],[0,1,1],[1,1,1],[1,0,1]] }, // Front
                                { dir: [0, 0,-1], corners: [[1,0,0],[1,1,0],[0,1,0],[0,0,0]] }, // Back
                                { dir: [1, 0, 0], corners: [[1,0,1],[1,1,1],[1,1,0],[1,0,0]] }, // Right
                                { dir: [-1, 0, 0], corners: [[0,0,0],[0,1,0],[0,1,1],[0,0,1]] }  // Left
                            ];

                            for (let face of faces) {
                                const [dx, dy, dz] = face.dir;
                                const neighborType = this.getBlock(x + dx, y + dy, z + dz);
                                
                                if (neighborType !== BlockType.AIR && 
                                    !(blockData[neighborType] && blockData[neighborType].transparent)) continue;

                                const color = new THREE.Color(data.color);
                                const brightness = dy === 1 ? 1.0 : dy === -1 ? 0.5 : 0.7;

                                for (let corner of face.corners) {
                                    vertices.push(
                                        worldX + corner[0],
                                        y + corner[1],
                                        worldZ + corner[2]
                                    );
                                    colors.push(
                                        color.r * brightness,
                                        color.g * brightness,
                                        color.b * brightness
                                    );
                                }

                                indices.push(
                                    vertexCount, vertexCount + 1, vertexCount + 2,
                                    vertexCount, vertexCount + 2, vertexCount + 3
                                );
                                vertexCount += 4;
                            }
                        }
                    }
                }

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();

                const material = new THREE.MeshLambertMaterial({
                    vertexColors: true,
                    flatShading: true
                });

                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                scene.add(this.mesh);
            }
        }

        function getChunk(x, z) {
            const key = `${x},${z}`;
            if (!chunks.has(key)) {
                chunks.set(key, new Chunk(x, z));
            }
            return chunks.get(key);
        }

        function updateChunks() {
            const playerChunkX = Math.floor(player.position.x / config.chunkSize);
            const playerChunkZ = Math.floor(player.position.z / config.chunkSize);

            // Carregar chunks pr√≥ximos
            for (let x = playerChunkX - config.renderDistance; x <= playerChunkX + config.renderDistance; x++) {
                for (let z = playerChunkZ - config.renderDistance; z <= playerChunkZ + config.renderDistance; z++) {
                    const chunk = getChunk(x, z);
                    if (!chunk.mesh) chunk.buildMesh();
                }
            }

            // Remover chunks distantes
            for (let [key, chunk] of chunks.entries()) {
                const [x, z] = key.split(',').map(Number);
                if (Math.abs(x - playerChunkX) > config.renderDistance + 2 ||
                    Math.abs(z - playerChunkZ) > config.renderDistance + 2) {
                    if (chunk.mesh) {
                        scene.remove(chunk.mesh);
                        chunk.mesh.geometry.dispose();
                        chunk.mesh = null;
                    }
                    chunks.delete(key);
                }
            }
        }

        // ==================== MOBS ====================
        class Mob {
            constructor(type, x, y, z) {
                this.type = type;
                this.health = 20;
                this.position = new THREE.Vector3(x, y, z);
                this.velocity = new THREE.Vector3(0, 0, 0);
                
                const configs = {
                    zombie: { color: 0x00AA00, size: [0.6, 1.8, 0.6], hostile: true },
                    skeleton: { color: 0xEEEEEE, size: [0.6, 1.8, 0.6], hostile: true },
                    creeper: { color: 0x00FF00, size: [0.6, 1.7, 0.6], hostile: true },
                    pig: { color: 0xFFC0CB, size: [0.9, 0.9, 0.9], hostile: false },
                    cow: { color: 0x8B4513, size: [0.9, 1.4, 0.9], hostile: false },
                    sheep: { color: 0xFFFFFF, size: [0.9, 1.3, 0.9], hostile: false }
                };

                const config = configs[type];
                const geometry = new THREE.BoxGeometry(...config.size);
                const material = new THREE.MeshLambertMaterial({ color: config.color });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                this.mesh.castShadow = true;
                scene.add(this.mesh);

                this.hostile = config.hostile;
                this.targetPlayer = false;
            }

            update(deltaTime) {
                if (this.health <= 0) return;

                const dist = this.position.distanceTo(player.position);

                if (this.hostile && dist < 16) {
                    this.targetPlayer = true;
                    const dir = new THREE.Vector3()
                        .subVectors(player.position, this.position)
                        .normalize();
                    this.velocity.x = dir.x * 0.08;
                    this.velocity.z = dir.z * 0.08;

                    if (dist < 2 && Math.random() < 0.02) {
                        damagePlayer(2);
                        audio.playSound('hurt');
                    }
                } else if (!this.targetPlayer) {
                    if (Math.random() < 0.01) {
                        this.velocity.x = (Math.random() - 0.5) * 0.05;
                        this.velocity.z = (Math.random() - 0.5) * 0.05;
                    }
                }

                this.velocity.y -= config.gravity;
                this.position.add(this.velocity);

                // Colis√£o com ch√£o
                if (this.position.y < 64) {
                    this.position.y = 64;
                    this.velocity.y = 0;
                }

                this.mesh.position.copy(this.position);
            }

            damage(amount) {
                this.health -= amount;
                this.mesh.material.emissive = new THREE.Color(0xFF0000);
                setTimeout(() => {
                    if (this.mesh.material) {
                        this.mesh.material.emissive = new THREE.Color(0x000000);
                    }
                }, 100);

                if (this.health <= 0) {
                    scene.remove(this.mesh);
                    const index = mobs.indexOf(this);
                    if (index > -1) mobs.splice(index, 1);
                    
                    // Drop de itens
                    if (Math.random() < 0.5) {
                        inventory.addItem(BlockType.WOOD, 1);
                    }
                }
            }
        }

        const mobs = [];

        function spawnMobs() {
            if (mobs.length < 20) {
                const types = gameState.time > 0.25 && gameState.time < 0.75 
                    ? ['pig', 'cow', 'sheep']
                    : ['zombie', 'skeleton', 'creeper', 'pig'];
                
                const type = types[Math.floor(Math.random() * types.length)];
                const angle = Math.random() * Math.PI * 2;
                const dist = 30 + Math.random() * 20;
                
                const mob = new Mob(
                    type,
                    player.position.x + Math.cos(angle) * dist,
                    70,
                    player.position.z + Math.sin(angle) * dist
                );
                mobs.push(mob);
            }
        }

        // ==================== CONTROLES ====================
        const keys = {};
        const mouse = { x: 0, y: 0, locked: false };

        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;

            if (e.key >= '1' && e.key <= '9' && !gameState.inventoryOpen) {
                gameState.selectedSlot = parseInt(e.key) - 1;
                updateHotbarUI();
            }

            if (e.key.toLowerCase() === 'e' && !gameState.paused) {
                toggleInventory();
            }

            if (e.key === 'Escape') {
                if (gameState.inventoryOpen) {
                    closeInventory();
                } else {
                    togglePause();
                }
            }

            if (e.key.toLowerCase() === 'f' && gameState.mode === 'creative') {
                gameState.isFlying = !gameState.isFlying;
                showMessage(gameState.isFlying ? 'Modo voo ativado' : 'Modo voo desativado');
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Mouse controls
        document.getElementById('gameCanvas').addEventListener('click', () => {
            if (!gameState.paused && !gameState.inventoryOpen) {
                document.getElementById('gameCanvas').requestPointerLock();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            mouse.locked = document.pointerLockElement === document.getElementById('gameCanvas');
        });

        document.addEventListener('mousemove', (e) => {
            if (!mouse.locked) return;

            mouse.x -= e.movementX * config.mouseSensitivity;
            mouse.y -= e.movementY * config.mouseSensitivity;
            mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouse.y));

            player.rotation.set(mouse.y, mouse.x, 0);
        });

        // Raycasting para blocos
        const raycaster = new THREE.Raycaster();

        document.addEventListener('mousedown', (e) => {
            if (!mouse.locked) return;

            audio.playSound('click');

            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyEuler(player.rotation);
            
            raycaster.set(camera.position, direction);

            // Verificar mobs primeiro
            const mobIntersects = [];
            mobs.forEach(mob => {
                const intersect = raycaster.intersectObject(mob.mesh);
                if (intersect.length > 0) {
                    mobIntersects.push({ distance: intersect[0].distance, mob });
                }
            });

            if (mobIntersects.length > 0 && e.button === 0) {
                mobIntersects.sort((a, b) => a.distance - b.distance);
                mobIntersects[0].mob.damage(5);
                audio.playSound('hurt', 0.5);
                return;
            }

            // Raycast para blocos
            let hitBlock = null;
            let hitDistance = Infinity;
            let hitFace = null;

            for (let dist = 0; dist < 5; dist += 0.1) {
                const checkPos = camera.position.clone().add(direction.clone().multiplyScalar(dist));
                const x = Math.floor(checkPos.x);
                const y = Math.floor(checkPos.y);
                const z = Math.floor(checkPos.z);

                const chunkX = Math.floor(x / config.chunkSize);
                const chunkZ = Math.floor(z / config.chunkSize);
                const chunk = getChunk(chunkX, chunkZ);

                const localX = x - chunkX * config.chunkSize;
                const localZ = z - chunkZ * config.chunkSize;
                const blockType = chunk.getBlock(localX, y, localZ);

                if (blockType !== BlockType.AIR) {
                    hitBlock = { x, y, z, type: blockType, chunk, localX, localZ };
                    hitDistance = dist;
                    
                    // Determinar face
                    const dx = checkPos.x - x - 0.5;
                    const dy = checkPos.y - y - 0.5;
                    const dz = checkPos.z - z - 0.5;
                    const adx = Math.abs(dx);
                    const ady = Math.abs(dy);
                    const adz = Math.abs(dz);
                    
                    if (adx > ady && adx > adz) hitFace = dx > 0 ? [1,0,0] : [-1,0,0];
                    else if (ady > adx && ady > adz) hitFace = dy > 0 ? [0,1,0] : [0,-1,0];
                    else hitFace = dz > 0 ? [0,0,1] : [0,0,-1];
                    
                    break;
                }
            }

            if (hitBlock) {
                if (e.button === 0) {
                    // Quebrar bloco
                    const data = blockData[hitBlock.type];
                    if (data && data.hardness >= 0) {
                        hitBlock.chunk.setBlock(hitBlock.localX, hitBlock.y, hitBlock.localZ, BlockType.AIR);
                        hitBlock.chunk.buildMesh();
                        
                        if (gameState.mode === 'survival' && data.drops) {
                            inventory.addItem(data.drops, 1);
                        }
                        
                        audio.playSound('dig_' + (data.tool || 'grass'));
                    }
                } else if (e.button === 2) {
                    // Colocar bloco
                    const item = inventory.hotbar[gameState.selectedSlot];
                    if (item && item.type && item.count > 0) {
                        const placeX = hitBlock.x + hitFace[0];
                        const placeY = hitBlock.y + hitFace[1];
                        const placeZ = hitBlock.z + hitFace[2];

                        const chunkX = Math.floor(placeX / config.chunkSize);
                        const chunkZ = Math.floor(placeZ / config.chunkSize);
                        const chunk = getChunk(chunkX, chunkZ);
                        const localX = placeX - chunkX * config.chunkSize;
                        const localZ = placeZ - chunkZ * config.chunkSize;

                        chunk.setBlock(localX, placeY, localZ, item.type);
                        chunk.buildMesh();

                        if (gameState.mode === 'survival') {
                            item.count--;
                            if (item.count === 0) item.type = null;
                            inventory.update();
                        }

                        audio.playSound('place');
                    }
                }
            }
        });

        document.addEventListener('contextmenu', (e) => e.preventDefault());

        // ==================== F√çSICA DO JOGADOR ====================
        function updatePlayer(deltaTime) {
            if (gameState.paused || gameState.inventoryOpen) return;

            const direction = new THREE.Vector3();
            const forward = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(0, player.rotation.y, 0));
            const right = new THREE.Vector3(1, 0, 0).applyEuler(new THREE.Euler(0, player.rotation.y, 0));

            const speed = keys['shift'] && !gameState.isFlying ? config.sprintSpeed : 
                         gameState.isFlying ? config.flySpeed : config.walkSpeed;

            if (keys['w']) direction.add(forward);
            if (keys['s']) direction.sub(forward);
            if (keys['d']) direction.add(right);
            if (keys['a']) direction.sub(right);

            if (direction.length() > 0) {
                direction.normalize();
                player.velocity.x = direction.x * speed;
                player.velocity.z = direction.z * speed;

                if (player.onGround && Math.random() < 0.1) {
                    audio.playSound('step_grass', 0.3);
                }
            } else {
                player.velocity.x *= 0.8;
                player.velocity.z *= 0.8;
            }

            if (gameState.isFlying) {
                player.velocity.y = 0;
                if (keys[' ']) player.velocity.y = config.flySpeed;
                if (keys['shift']) player.velocity.y = -config.flySpeed;
            } else {
                player.velocity.y -= config.gravity;
                
                if (keys[' '] && player.onGround) {
                    player.velocity.y = config.jumpForce;
                    audio.playSound('jump');
                }
            }

            player.position.add(player.velocity);

            // Colis√£o b√°sica com o ch√£o
            if (player.position.y < 64) {
                player.position.y = 64;
                player.velocity.y = 0;
                player.onGround = true;
            } else {
                player.onGround = false;
            }

            camera.position.copy(player.position);
            camera.rotation.copy(player.rotation);

            updateChunks();
        }

        // ==================== CICLO DIA/NOITE ====================
        function updateDayNight() {
            gameState.time += 0.0001;
            if (gameState.time >= 1) {
                gameState.time = 0;
                gameState.day++;
            }

            // Atualizar ilumina√ß√£o
            const dayProgress = gameState.time;
            let intensity, color;

            if (dayProgress < 0.25) {
                // Noite
                intensity = 0.2;
                color = 0x4040ff;
                scene.background = new THREE.Color(0x001020);
            } else if (dayProgress < 0.35) {
                // Amanhecer
                const t = (dayProgress - 0.25) / 0.1;
                intensity = 0.2 + t * 0.6;
                color = 0xff8040;
                scene.background = new THREE.Color(0x804020);
            } else if (dayProgress < 0.75) {
                // Dia
                intensity = 0.8;
                color = 0xffffff;
                scene.background = new THREE.Color(0x87CEEB);
            } else {
                // Anoitecer
                const t = (dayProgress - 0.75) / 0.25;
                intensity = 0.8 - t * 0.6;
                color = 0xff6040;
                scene.background = new THREE.Color(0x603010);
            }

            window.sun.intensity = intensity;
            window.sun.color = new THREE.Color(color);
            window.ambientLight.intensity = intensity * 0.6;

            const hour = Math.floor(dayProgress * 24);
            const minute = Math.floor((dayProgress * 24 - hour) * 60);
            document.getElementById('timeInfo').textContent = 
                `Dia ${gameState.day}, ${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
        }

        // ==================== UI ====================
        function updateHotbarUI() {
            const hotbar = document.getElementById('hotbar');
            hotbar.innerHTML = '';

            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot' + (i === gameState.selectedSlot ? ' selected' : '');
                
                const item = inventory.hotbar[i];
                if (item && item.type && blockData[item.type]) {
                    const img = document.createElement('div');
                    img.className = 'slot-item';
                    img.style.background = `linear-gradient(135deg, ${
                        '#' + blockData[item.type].color.toString(16).padStart(6, '0')
                    }, ${
                        '#' + (blockData[item.type].color - 0x202020).toString(16).padStart(6, '0')
                    })`;
                    slot.appendChild(img);

                    if (item.count > 1) {
                        const count = document.createElement('div');
                        count.className = 'slot-count';
                        count.textContent = item.count;
                        slot.appendChild(count);
                    }
                }

                slot.onclick = () => {
                    gameState.selectedSlot = i;
                    updateHotbarUI();
                    audio.playSound('click');
                };

                hotbar.appendChild(slot);
            }
        }

        function updateInventoryUI() {
            const grids = {
                inventoryGrid: inventory.slots,
                inventoryHotbar: inventory.hotbar,
                craftingGrid: inventory.crafting
            };

            for (let [gridId, items] of Object.entries(grids)) {
                const grid = document.getElementById(gridId);
                if (!grid) continue;

                grid.innerHTML = '';
                items.forEach((item, i) => {
                    const slot = document.createElement('div');
                    slot.className = 'inventory-slot';

                    if (item && item.type && blockData[item.type]) {
                        const img = document.createElement('div');
                        img.className = 'slot-item';
                        img.style.background = `linear-gradient(135deg, ${
                            '#' + blockData[item.type].color.toString(16).padStart(6, '0')
                        }, ${
                            '#' + (blockData[item.type].color - 0x202020).toString(16).padStart(6, '0')
                        })`;
                        slot.appendChild(img);

                        if (item.count > 1) {
                            const count = document.createElement('div');
                            count.className = 'slot-count';
                            count.textContent = item.count;
                            slot.appendChild(count);
                        }
                    }

                    grid.appendChild(slot);
                });
            }

            // Atualizar resultado do crafting
            const result = checkCrafting();
            const resultSlot = document.getElementById('craftingResult');
            if (resultSlot) {
                resultSlot.innerHTML = '';
                if (result && blockData[result.type]) {
                    const img = document.createElement('div');
                    img.className = 'slot-item';
                    img.style.background = `linear-gradient(135deg, ${
                        '#' + blockData[result.type].color.toString(16).padStart(6, '0')
                    }, ${
                        '#' + (blockData[result.type].color - 0x202020).toString(16).padStart(6, '0')
                    })`;
                    resultSlot.appendChild(img);

                    if (result.count > 1) {
                        const count = document.createElement('div');
                        count.className = 'slot-count';
                        count.textContent = result.count;
                        resultSlot.appendChild(count);
                    }
                }
            }
        }

        function updateHealthBar() {
            const bar = document.getElementById('healthBar');
            bar.innerHTML = '';
            for (let i = 0; i < 10; i++) {
                const heart = document.createElement('div');
                const health = gameState.health;
                if (i * 2 < health) {
                    heart.className = i * 2 + 1 < health ? 'heart' : 'heart half';
                } else {
                    heart.className = 'heart empty';
                }
                bar.appendChild(heart);
            }
        }

        function updateHungerBar() {
            const bar = document.getElementById('hungerBar');
            bar.innerHTML = '';
            for (let i = 0; i < 10; i++) {
                const food = document.createElement('div');
                food.className = i * 2 < gameState.hunger ? 'hunger' : 'hunger empty';
                bar.appendChild(food);
            }
        }

        function showMessage(text) {
            const msg = document.createElement('div');
            msg.className = 'message';
            msg.textContent = text;
            document.getElementById('messages').appendChild(msg);
            setTimeout(() => msg.remove(), 5000);
        }

        function damagePlayer(amount) {
            if (gameState.mode === 'creative') return;
            
            gameState.health = Math.max(0, gameState.health - amount);
            updateHealthBar();
            audio.playSound('hurt');

            if (gameState.health === 0) {
                showMessage('Voc√™ morreu!');
                setTimeout(() => {
                    if (confirm('Respawnar?')) {
                        gameState.health = 20;
                        gameState.hunger = 20;
                        player.position.set(0, 70, 0);
                        updateHealthBar();
                        updateHungerBar();
                    } else {
                        quitToMenu();
                    }
                }, 2000);
            }
        }

        // ==================== GAME LOOP ====================
        let lastTime = performance.now();
        let frames = 0;
        let fpsTime = 0;

        function gameLoop() {
            requestAnimationFrame(gameLoop);

            const now = performance.now();
            const deltaTime = (now - lastTime) / 1000;
            lastTime = now;

            if (!gameState.paused && !gameState.inventoryOpen) {
                updatePlayer(deltaTime);
                updateDayNight();
                
                mobs.forEach(mob => mob.update(deltaTime));
                
                if (Math.random() < 0.001) spawnMobs();

                // Atualizar posi√ß√£o
                document.getElementById('posInfo').textContent = 
                    `X: ${Math.floor(player.position.x)} Y: ${Math.floor(player.position.y)} Z: ${Math.floor(player.position.z)}`;
            }

            renderer.render(scene, camera);

            // FPS counter
            frames++;
            fpsTime += deltaTime;
            if (fpsTime >= 1) {
                document.getElementById('fpsCounter').textContent = `FPS: ${frames}`;
                frames = 0;
                fpsTime = 0;
            }
        }

        // ==================== MENU FUNCTIONS ====================
        function startGame(mode) {
            gameState.mode = mode;
            
            document.getElementById('loading').style.display = 'flex';
            document.getElementById('mainMenu').style.display = 'none';

            let progress = 0;
            const loadInterval = setInterval(() => {
                progress += 10;
                document.getElementById('loadingProgress').style.width = progress + '%';
                
                if (progress >= 100) {
                    clearInterval(loadInterval);
                    
                    initThree();
                    audio.init();
                    audio.playMusic();
                    
                    // Items iniciais
                    if (mode === 'creative') {
                        Object.keys(BlockType).forEach((key, i) => {
                            if (i > 0 && i < 10) {
                                inventory.hotbar[i-1] = { type: BlockType[key], count: 64 };
                            }
                        });
                    } else {
                        inventory.addItem(BlockType.WOOD, 3);
                        inventory.addItem(BlockType.DIRT, 10);
                    }
                    
                    updateHotbarUI();
                    updateHealthBar();
                    updateHungerBar();
                    
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('gameCanvas').style.display = 'block';
                    document.getElementById('gameHUD').style.display = 'block';
                    
                    showMessage('üéÆ Bem-vindo ao Minecraft!');
                    showMessage('Pressione ESC para pausar ou E para invent√°rio');
                    
                    gameLoop();
                }
            }, 100);
        }

        function toggleInventory() {
            gameState.inventoryOpen = !gameState.inventoryOpen;
            document.getElementById('inventory').style.display = gameState.inventoryOpen ? 'block' : 'none';
            if (gameState.inventoryOpen) {
                updateInventoryUI();
                document.exitPointerLock();
            }
            audio.playSound('click');
        }

        function closeInventory() {
            gameState.inventoryOpen = false;
            document.getElementById('inventory').style.display = 'none';
        }

        function togglePause() {
            gameState.paused = !gameState.paused;
            document.getElementById('pauseMenu').style.display = gameState.paused ? 'flex' : 'none';
            if (gameState.paused) document.exitPointerLock();
            audio.playSound('click');
        }

        function resumeGame() {
            gameState.paused = false;
            document.getElementById('pauseMenu').style.display = 'none';
            audio.playSound('click');
        }

        function saveGame() {
            const saveData = {
                player: {
                    position: player.position.toArray(),
                    health: gameState.health,
                    hunger: gameState.hunger
                },
                inventory: {
                    slots: inventory.slots,
                    hotbar: inventory.hotbar
                },
                gameState: gameState
            };
            localStorage.setItem('minecraftSave', JSON.stringify(saveData));
            showMessage('üíæ Jogo salvo com sucesso!');
            audio.playSound('click');
        }

        function loadGame() {
            const data = localStorage.getItem('minecraftSave');
            if (!data) {
                alert('Nenhum jogo salvo encontrado!');
                return;
            }
            
            try {
                const save = JSON.parse(data);
                gameState.mode = save.gameState.mode || 'survival';
                startGame(gameState.mode);
                
                setTimeout(() => {
                    player.position.fromArray(save.player.position);
                    gameState.health = save.player.health;
                    gameState.hunger = save.player.hunger;
                    inventory.slots = save.inventory.slots;
                    inventory.hotbar = save.inventory.hotbar;
                    
                    updateHealthBar();
                    updateHungerBar();
                    updateHotbarUI();
                    
                    showMessage('‚úÖ Jogo carregado!');
                }, 1500);
            } catch(e) {
                alert('Erro ao carregar jogo!');
            }
        }

        function showOptions() {
            alert('‚öôÔ∏è OP√á√ïES\n\nControles:\n‚Ä¢ WASD - Mover\n‚Ä¢ Espa√ßo - Pular/Voar\n‚Ä¢ Shift - Correr/Descer\n‚Ä¢ F - Alternar voo (Criativo)\n‚Ä¢ E - Invent√°rio\n‚Ä¢ 1-9 - Selecionar item\n‚Ä¢ Mouse - Olhar\n‚Ä¢ Click Esquerdo - Quebrar\n‚Ä¢ Click Direito - Colocar\n‚Ä¢ ESC - Pausar');
        }

        function quitToMenu() {
            location.reload();
        }

        function quitGame() {
            if (confirm('Deseja realmente sair do jogo?')) {
                window.close();
            }
        }

        // Resize handler
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // Inicializa√ß√£o
        console.log('üéÆ Minecraft carregado! Pressione qualquer bot√£o do menu para come√ßar.');
    </script>
</body>
</html>
